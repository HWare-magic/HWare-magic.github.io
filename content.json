{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Hware-magic","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-11-27T08:58:59.000Z","updated":"2022-11-27T09:10:31.551Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"1111"},{"title":"tags","date":"2022-11-27T08:40:47.000Z","updated":"2022-11-27T08:41:54.555Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"!11111"}],"posts":[{"title":"np and pd datatype","slug":"np-and-pd-datatype","date":"2022-12-14T19:51:14.000Z","updated":"2022-12-14T19:59:47.467Z","comments":true,"path":"2022/12/15/np-and-pd-datatype/","link":"","permalink":"http://example.com/2022/12/15/np-and-pd-datatype/","excerpt":"","text":"numpy array 创建方式 123456789a=np.array([1,2,3,4],dtype=float,copy=True) # 其作用是将其他类型的数据转化为np.array# np.array的创建 有以下几种方式#创建空数组np.empty((3,4))## 创建全零np.zeros((3,4))np.zeros_like(a)#创建全一np.ones((3,4),order=&#x27;F&#x27;) pd.dataFrame 创建方法 12b= pd.DataFrame()b[][] #等同于b[].values[] 第一个[]的切片为serial 第二个的切片为np.array np的一维会被当成df的一个serial 也就是可以认为是一列 通过df的切片访问到的是serial对象 通过serial对象的values可以变为np.array 这时对np.array就可以进行切片得到单元格的数据 还可以通过对df的行列同时进行切片得到np类型数据","categories":[{"name":"编程","slug":"programming","permalink":"http://example.com/categories/programming/"}],"tags":[]},{"title":"Chatgpt","slug":"Chatgpt","date":"2022-12-08T17:51:39.000Z","updated":"2022-12-08T18:27:52.115Z","comments":true,"path":"2022/12/09/Chatgpt/","link":"","permalink":"http://example.com/2022/12/09/Chatgpt/","excerpt":"","text":"名称由来 主要是GPT（generate pre-train transformer），谷歌开发的openai中的爆火人机聊天工具，有替代主流搜索的趋势 使用效果 image-20221209020132275 image-20221209020206138 实现简单的一元二次方程的结果，完全正确，直接一键复制 image-20221209020345842 关于简单的demo程序 完全没问题,甚至可以进一步优化 image-20221209020432428 image-20221209020548352 算法框架也没问题 轻轻松松,感受下它的恐怖吧 甚至有注释 1234567891011121314151617181920212223242526272829303132333435363738394041import torchimport torch.nn as nn# 定义GRU网络class GRU(nn.Module): def __init__(self, input_size, hidden_size, num_layers): super(GRU, self).__init__() self.gru = nn.GRU(input_size, hidden_size, num_layers) def forward(self, input, hidden): output, hidden = self.gru(input, hidden) return output, hidden# 定义损失函数criterion = nn.CrossEntropyLoss()# 定义优化器optimizer = torch.optim.Adam(model.parameters())# 训练模型for epoch in range(num_epochs): hidden = None for inputs, labels in train_data: # 清空梯度 optimizer.zero_grad() # 前向计算 outputs, hidden = model(inputs, hidden) # 计算损失 loss = criterion(outputs, labels) # 反向传播 loss.backward() # 更新参数 optimizer.step()# 保存模型torch.save(model.state_dict(), &#x27;model.pth&#x27;) 提出优化需求 image-20221209020726410 123456789101112131415161718192021# 定义MSE损失函数criterion = nn.MSELoss()# 训练模型for epoch in range(num_epochs): hidden = None for inputs, labels in train_data: # 清空梯度 optimizer.zero_grad() # 前向计算 outputs, hidden = model(inputs, hidden) # 计算损失 loss = criterion(outputs, labels) # 反向传播 loss.backward() # 更新参数 image-20221209020852286 1234567891011121314151617181920212223242526272829303132import torch# 自定义损失函数def custom_loss(outputs, labels): loss = torch.abs(outputs - labels).mean() return loss# 定义优化器optimizer = torch.optim.Adam(model.parameters())# 训练模型for epoch in range(num_epochs): hidden = None for inputs, labels in train_data: # 清空梯度 optimizer.zero_grad() # 前向计算 outputs, hidden = model(inputs, hidden) # 计算损失 loss = custom_loss(outputs, labels) # 反向传播 loss.backward() # 更新参数 optimizer.step()# 保存模型torch.save(model.state_dict(), &#x27;model.pth&#x27;) image-20221209020941208 这里应该是重复的问题了 1234567891011121314151617181920212223242526272829303132import torch# 自定义损失函数def custom_loss(outputs, labels): loss = torch.abs(outputs - labels).mean() return loss# 定义优化器optimizer = torch.optim.Adam(model.parameters())# 训练模型for epoch in range(num_epochs): hidden = None for inputs, labels in train_data: # 清空梯度 optimizer.zero_grad() # 前向计算 outputs, hidden = model(inputs, hidden) # 计算损失 loss = custom_loss(outputs, labels) # 反向传播 loss.backward() # 更新参数 optimizer.step()# 保存模型torch.save(model.state_dict(), &#x27;model.pth&#x27;) image-20221209021131138 image-20221209021149585 12345678910111213141516171819202122232425import torchimport torch.nn as nn# 定义网络class Net(nn.Module): def __init__(self, input_size, hidden_size, num_layers): super(Net, self).__init__() self.fc1 = nn.Lin# 定义网络class Net(nn.Module): def __init__(self, input_size, hidden_size, num_layers): super(Net, self).__init__() self.fc1 = nn.Linear(input_size, hidden_size) self.fc2 = nn.Linear(hidden_size, 1) def forward(self, inputs, covariates): # 拼接数据 inputs = torch.cat([inputs, covariates], dim=1) # 前向计算 hidden = self.fc1(inputs) outputs = self.fc2(hidden) return outputs image-20221209021326985 12345678910111213141516171819# 保存模型torch.save(model.state_dict(), &#x27;model.pth&#x27;)# 加载模型model.load_state_dict(torch.load(&#x27;model.pth&#x27;))pip install torchvizimport torchviz# 可视化模型torchviz.make_dot(model(inputs))# 可视化模型graph = torchviz.make_dot(model(inputs))# 保存图片graph.save(&#x27;model.png&#x27;) image-20221209021449986 1234567891011# 获取模型的参数params = model.state_dict()# 输出第一层的参数print(params[&#x27;fc1.weight&#x27;])print(params[&#x27;fc1.bias&#x27;])# 输出第二层的参数print(params[&#x27;fc2.weight&#x27;])print(params[&#x27;fc2.bias&#x27;]) image-20221209021557959 image-20221209021619119 都是些日常会遇到的一些问题，通过搜索引擎回答的效果 远不如它 它的结构 这个是通过学习李弘毅的分析来的，有可能有差错 首先它能实现了是NLP 就是文字续写 人类的指导文字接龙的方向 （这里有人类来思考GPT的问题，并且需要提供正确答案） 这里没有穷尽所有问题的答案 人类的作用是选择答案 模范人类的喜好（感觉和第二步是类似的，后续是使用一个teacher model 来打分） 用增强学习的方式向模拟老师学习 ，把上面的模型来进行调整参数，也就是增强学习的reward","categories":[{"name":"编程","slug":"programming","permalink":"http://example.com/categories/programming/"}],"tags":[]},{"title":"circuit_design","slug":"circuit-design","date":"2022-12-02T15:41:09.000Z","updated":"2022-12-02T15:43:59.275Z","comments":true,"path":"2022/12/02/circuit-design/","link":"","permalink":"http://example.com/2022/12/02/circuit-design/","excerpt":"","text":"信号处理电路 信号处理电路主要利用集成运算放大器或专用模拟集成电路， 配以少量的外接元件可以构成各种功能的处理电路。主要功能有信号放大、信号滤波、阻抗匹配、电平变换、非线性补偿、电流/电压转换、电压/频率转换等。上图，运放组成的有源低通滤波器。","categories":[{"name":"circuit","slug":"circuit","permalink":"http://example.com/categories/circuit/"}],"tags":[]},{"title":"CIM learning","slug":"CIM-learning","date":"2022-11-27T20:59:57.000Z","updated":"2022-11-27T21:02:59.389Z","comments":true,"path":"2022/11/28/CIM-learning/","link":"","permalink":"http://example.com/2022/11/28/CIM-learning/","excerpt":"","text":"首先介绍什么是存算：顾名思义是指存储和计算在一起发生 ，有别于经典的冯诺伊曼结构 分为处理器和存储器 这是将两者结合在一起的器件 有以下几个优点 计算速度快，减少了从存储单元到计算单元的时间，可以避免所谓的存储墙的限制 在数据变化较小的场景有优势 运行速率有很大的提升 不足在于 会有很多冗余单元 使得功耗大资源利用率低 同时当输入较大时 所需的输入带宽特别的大 在物联网的边缘设备还是有空间的 关于存储器的介绍 目前主流的存算还是在DRAM 上操作的 因为成本较低 工艺成熟 还有在flash上做的 模拟的存算居多","categories":[{"name":"概念","slug":"概念","permalink":"http://example.com/categories/%E6%A6%82%E5%BF%B5/"}],"tags":[]},{"title":"test","slug":"test","date":"2022-11-27T08:56:37.000Z","updated":"2022-11-27T09:32:29.528Z","comments":true,"path":"2022/11/27/test/","link":"","permalink":"http://example.com/2022/11/27/test/","excerpt":"","text":"11111111","categories":[{"name":"编程","slug":"programming","permalink":"http://example.com/categories/programming/"}],"tags":[]},{"title":"virtuoso_calculate_power","slug":"virtuoso-calculate-power","date":"2022-11-25T13:42:11.000Z","updated":"2022-11-27T09:29:31.851Z","comments":true,"path":"2022/11/25/virtuoso-calculate-power/","link":"","permalink":"http://example.com/2022/11/25/virtuoso-calculate-power/","excerpt":"","text":"关于使用virtuoso 仿真信号是计算平均功耗 进入EDA软件 1vittuoso &amp; 打开原理图画面 image-20221125212558624 2.进入ADE L 的仿真页面 image-20221125212942911 3.在输出页面进行计算 image-20221125213056788 4.计算电压和电流的平均值 打开计算器后 先在曲线页面选中需要操作的线，再点击所需的函数 如 average image-20221125213342915 看出输出 image-20221125213413732","categories":[],"tags":[]},{"title":"Python - Argparse_guidebook","slug":"Python-Argparse-guidebook","date":"2022-11-24T16:00:17.000Z","updated":"2022-11-27T09:28:42.358Z","comments":true,"path":"2022/11/25/Python-Argparse-guidebook/","link":"","permalink":"http://example.com/2022/11/25/Python-Argparse-guidebook/","excerpt":"主要学习官网文档 模块功能的介绍 argparse 模块的作用就是 在程序外加一个接口 通过命令的方式 向程序传入参数 可类比 ls -l 的例子 其中 -l就是可以看成一个参数 该模块 也有很多的参数 有可选参数 和默认的参数 其特点是 所有参数 均可自行定义","text":"主要学习官网文档 模块功能的介绍 argparse 模块的作用就是 在程序外加一个接口 通过命令的方式 向程序传入参数 可类比 ls -l 的例子 其中 -l就是可以看成一个参数 该模块 也有很多的参数 有可选参数 和默认的参数 其特点是 所有参数 均可自行定义 123import argparse ## 导入模块parser = argparse.ArgumentParser() ## 定义模块的声明 在括号内可以添加 描述性的内容parser.parse_args() ## 用于获取传进来的参数 类似于字典形式 可以通过args.参数名的形式访问 位置参数的介绍 12345import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;echo&quot;) ## 添加参数args = parser.parse_args() print(args.echo) ## 把输入的参数保存在这里 12python3 prog.py foo ## 输入foo ## 输出 还可以添加一些描述性的内容 12345import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;echo&quot;, help=&quot;echo the string you use here&quot;) ## 这里出现提示 使用 help=‘’args = parser.parse_args()print(args.echo) 当输入的参数未声明类型的时候 默认是字符所以无法进行数字运算 123456789101112import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;square&quot;, help=&quot;display a square of a given number&quot;)args = parser.parse_args()print(args.square**2 ## 输出结果python3 prog.py 4Traceback (most recent call last): File &quot;prog.py&quot;, line 5, in &lt;module&gt; print(args.square**2)TypeError: unsupported operand type(s) for ** or pow(): &#x27;str&#x27; and &#x27;int 通过在add方法中 加入type = int 来指定类型 123456import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;square&quot;, help=&quot;display a square of a given number&quot;, type=int) ## 这里指定了了输入的类型args = parser.parse_args()print(args.square**2 可选参数介绍（使用- 来表示） 1234567import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;--verbosity&quot;, help=&quot;increase output verbosity&quot;)## -- 表示为可选参数args = parser.parse_args()if args.verbosity: print(&quot;verbosity turned on&quot;) 可以给参数接受的类型时 如果只有两种选择 True and False，可以采用action = 'store_true'来表示 1234567891011121314import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;--verbose&quot;, help=&quot;increase output verbosity&quot;, action=&quot;store_true&quot;)## 这里表示 verbose参数只有两种情况#为 args.verbose 赋值为 True。没有指定时则隐含地赋值为 Falseargs = parser.parse_args()if args.verbose: print(&quot;verbosity turned on&quot;)## 输出 python3 prog.py --verbose ## 指定时 为True 如果没有指定 则为falseverbosity turned on python3 prog.py --verbose 1 ## 这时不能再指定其他类型usage: prog.py [-h] [--verbose]prog.py: error: unrecognized arguments: 1 短选项 可以使用一个-和一个字母来代替较长的参数 12345678910import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, help=&quot;increase output verbosity&quot;, action=&quot;store_true&quot;) ## 这里在输入参数时 使用 -v 和使用 --verbose一样args = parser.parse_args()if args.verbose: print(&quot;verbosity turned on&quot;) ## 输出 python3 prog.py -v verbosity turned o 结合位置参数和可选参数 123456789101112131415161718192021222324import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;square&quot;, type=int, help=&quot;display a square of a given number&quot;)parser.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, help=&quot;increase output verbosity&quot;) ## 这里两个参数 一个是必填参数 一个是可选参数 可以从结果看出两者的区别args = parser.parse_args()answer = args.square**2if args.verbose: print(f&quot;the square of &#123;args.square&#125; equals &#123;answer&#125;&quot;)else: print(answer) ##输出python3 prog.pyusage: prog.py [-h] [-v] squareprog.py: error: the following arguments are required: square ## 不输入必选参数会报错的python3 prog.py 416python3 prog.py 4 --verbose the square of 4 equals 16python3 prog.py --verbose 4the square of 4 equals 16 我们带回了一个位置参数，结果发生了报错。 注意顺序无关紧要 还可有通过choices 关键字来限定参数的输入范围 123456789101112131415import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;square&quot;, type=int, help=&quot;display a square of a given number&quot;)parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, type=int, choices=[0, 1, 2], help=&quot;increase output verbosity&quot;)## 这里choices 限定了 只能在0 1 2 中选args = parser.parse_args()answer = args.square**2if args.verbosity == 2: print(f&quot;the square of &#123;args.square&#125; equals &#123;answer&#125;&quot;)elif args.verbosity == 1: print(f&quot;&#123;args.square&#125;^2 == &#123;answer&#125;&quot;)else: print(answer) 还可以用count参数来表示输入参数的数字 123456789101112131415161718192021222324252627import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;square&quot;, type=int, help=&quot;display the square of a given number&quot;)parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, action=&quot;count&quot;, help=&quot;increase output verbosity&quot;)## 这里count 表示参数出现的个数 表且将这个数字传进来 -vv 等于2 -v等于1args = parser.parse_args()answer = args.square**2if args.verbosity == 2: print(f&quot;the square of &#123;args.square&#125; equals &#123;answer&#125;&quot;)elif args.verbosity == 1: print(f&quot;&#123;args.square&#125;^2 == &#123;answer&#125;&quot;)else: print(answer) ## 输出python3 prog.py 416python3 prog.py 4 -v4^2 == 16python3 prog.py 4 -vvthe square of 4 equals 16python3 prog.py 4 --verbosity --verbositythe square of 4 equals 16python3 prog.py 4 -v 1usage: prog.py [-h] [-v] squareprog.py: error: unrecognized arguments: 还可以加入一些默认值 default 1234567891011121314151617181920212223242526272829import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, action=&quot;count&quot;, default=0) ## 当可选参数为出现时 默认为0args = parser.parse_args()answer = args.x**args.yif args.verbosity &gt;= 2: print(f&quot;&#123;args.x&#125; to the power &#123;args.y&#125; equals &#123;answer&#125;&quot;)elif args.verbosity &gt;= 1: print(f&quot;&#123;args.x&#125;^&#123;args.y&#125; == &#123;answer&#125;&quot;)else: print(answer) ## 输出 python3 prog.pyusage: prog.py [-h] [-v] x yprog.py: error: the following arguments are required: x, ypython3 prog.py -husage: prog.py [-h] [-v] x ypositional arguments: x the base y the exponentoptions: -h, --help show this help message and exit -v, --verbositypython3 prog.py 4 2 -v4^2 == 16 以及有可能两个参数产生矛盾 要尽可能避免 123456789101112131415161718192021222324252627282930313233import argparseparser = argparse.ArgumentParser()group = parser.add_mutually_exclusive_group()group.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;)group.add_argument(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_true&quot;)parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)args = parser.parse_args()answer = args.x**args.yif args.quiet: print(answer)elif args.verbose: print(f&quot;&#123;args.x&#125; to the power &#123;args.y&#125; equals &#123;answer&#125;&quot;)else: print(f&quot;&#123;args.x&#125;^&#123;args.y&#125; == &#123;answer&#125;&quot;) # 输出 python3 prog.py 4 24^2 == 16python3 prog.py 4 2 -q16python3 prog.py 4 2 -v4 to the power 2 equals 16python3 prog.py 4 2 -vqusage: prog.py [-h] [-v | -q] x yprog.py: error: argument -q/--quiet: not allowed with argument -v/--verbosepython3 prog.py 4 2 -v --quietusage: prog.py [-h] [-v | -q] x yprog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose ## 当q v 两个参数同时出现时 不知道该执行 if 还是elif 因为这里没有顺序的问题","categories":[],"tags":[]},{"title":"hexo ——setting","slug":"picture","date":"2022-11-22T13:05:55.000Z","updated":"2022-11-27T11:13:07.588Z","comments":true,"path":"2022/11/22/picture/","link":"","permalink":"http://example.com/2022/11/22/picture/","excerpt":"插入图片 image 开始的时候 md文件可以显示 但是在网页上无法显示图片 后经过设置才可显示上图的样子 遂mark解决方式 原因:据说是编解码的问题","text":"插入图片 image 开始的时候 md文件可以显示 但是在网页上无法显示图片 后经过设置才可显示上图的样子 遂mark解决方式 原因:据说是编解码的问题 解决方案： 使用hexo官方的解决方案,使用模版变量, {% asset_img slug [title] %} 该方法可行性不好 因为这样在typaro和vscode中无法显示 那么写内容时和不合 步骤 配置hexo的_config.yml文件, 将 post_asset_folder 设置为true, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径 在博客根目录中下使用npm安装插件：npm install https://github.com/CodeFalling/hexo-asset-image --save image-20221122222835738 后续需要将图片放入到对应的文件夹下，但是对于很多截图很不方便 因此对于typora 通过设置（对偏好设置下的图片设置）可使得自动的将图片存入对应文件夹下： image-20221122223534958 以后直接粘贴图片就可以自动保存到 hexo 配置的 post_asset_folder 文件夹里,自动渲染了 注意这时的插入的格式为名称（文件夹图片名） 需要改为名称（文件夹图片名） 参考文章链接：解决Hexo博客不显示图片的一种方法 - 简书 (jianshu.com) 插入公式(解决起来比较困难) Hexo渲染LaTeX公式关键（开始使用的时yaili 的主题出现了一些问题 在本地可以实现公式的显示 在网页上没有，现在补充最终版） Hexo渲染主题的两个重要因素：mathjax和kramed，前者是数学公式渲染引擎，后者是Hexo的markdown渲染引擎，hexo默认渲染引擎是marked，但是它不支持mathjax，因此需要替换引擎 1.Hexo添加mathjax 1.如果hexo安装有hexo-math,需要先卸载它。卸载命令： npm uninstall hexo-math --save 2.安装mathjax，安装命令： npm install hexo-renderer-mathjax --save 3.hexo主题开启mathjax：这里和参考的文章不同 我才用的主题时github上下载的yilia主题 image-20221122224909378 配置yilia中的_config.yml文件(将mathjax：false 改为 true) image-20221122225057267 2.hexo切换kramed引擎 1.卸载marked引擎 npm uninstall hexo-renderer-marked --save 2.安装kramed引擎 npm install hexo-renderer-kramed --save 3.修改引擎bug: 修改文件/node_modules\\kramed\\lib\\rules\\inline.js中escape和em两行，具体修改如下： 12// escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 4.重新启动hexo: 1hexo clean &amp;&amp; hexo g -d 可显示公式： 参考文章：Hexo渲染LaTeX公式 - 简书 (jianshu.com) 公式显示最终版 采用的是pandoc的插件 1.首先需要安装 pandoc： ​ Pandoc - 下载地址 安装后需要记住安装路径后续用 2.来到博客目录 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 3 安装hexo-math 插件 1npm install hexo-math --save 4.在hexo 博客中的 _config.yml 中添加 hexo-math 插件 12345678markdown: plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji - hexo-math 5.以目前最流行的 NeXT 为例, 打开 theme/next/_config.yml 文件，找到mathjax 位置, 设置为以下 123456# MathJax Supportmathjax: enable: true per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/ 5.在每一个博客中都打开 mathjax 开关 1234title: 通过设置使得hexo正常显示图片和公式date: 2022-11-22 21:05:55tags:mathjax: true 6.重新编译以下 123hexo cleanhexo generatehexo s 注意如果hexo g 时v互相如下报错 [hexo-renderer-pandoc] pandoc exited with code null. 那么需要在博客页面的 _config.yml文件下添加 12pandoc: pandoc_path: C:/Program Files/Pandoc/pandoc.exe #(路径需要改为刚才安装pandoc的路径) 重新编译和部署即可 还有一点需要注意的是：插入的公式和$符号间不可以有空格 否则无法显示 在hexo 根目录下的设置 12345678# Sitetitle: Hexo subtitle: ''description: ''keywords:author: Hware-magic ## 作者名称language: zh-CN #en # 中文timezone: Asia/Shanghai #'' ## 时区设置 设置不对 在tag 和 分类上也会出错 添加标签页和分类页 在next 主题的设置文件下_config.yml 123456789menu: ## 可以添加页面 home: / || fa fa-home about: /about/ || fa fa-user tags: /tags/ || fa fa-tags ## charge for tag and categories categories: /categories/ || fa fa-th #archives: /archives/ || fa fa-archive #schedule: /schedule/ || fa fa-calendar #sitemap: /sitemap.xml || fa fa-sitemap #commonweal: /404/ || fa fa-heartbeat 效果如下 image-20221127185450077 正确打开标签页和分类页 1hexo n page tags 就会在source中创建tags文件夹，并在里面创建index.md文件，表示已经可以使用 然后打开index.md 进行修改 image-20221127185814449 对于分类页同理，hexo n page categories 然后修改的时候type: \"categories\" 主题样式的更改 在next的主题配置文件里面 找到Schemes ，发现有四种主题： 要用哪个就把哪个前面的#去掉，其它的三个加上# (#代表注释)； image-20200628141115598 首页文章设置阅读全文 next的配置文件下，找到这里 image-20221127190344421 把这两个都设置为true，默认应该是true； 然后有两种方法 在博客的头部 添加description，然后在后面输入你的描述，那么在你的博客中，这篇文章就只会显示你写的描述，剩下的由阅读全文这个按钮代替； image-20221127190637048 第二种办法： 在文章中输入这一行代码，那么默认这行代码之前的部分为描述，之后的部分在阅读全文中显示 1&lt;!-- more --&gt; 增加搜索功能 下载依赖 1npm install hexo-generator-seachdb -save next的配置文件中，置local_search为true image-20221127190945039","categories":[],"tags":[]},{"title":"深度学习关于数据归一化的做法","slug":"深度学习关于数据归一化的做法","date":"2022-11-02T17:00:41.000Z","updated":"2022-11-27T09:30:37.117Z","comments":true,"path":"2022/11/03/深度学习关于数据归一化的做法/","link":"","permalink":"http://example.com/2022/11/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%81%9A%E6%B3%95/","excerpt":"","text":"算法介绍 我的数据格式 ：是70个时序数据为一个特征 对应一个label 就是一个向量 我需要做的是将每个特征中的70个数据 归一化成均值为零 方差为一的特征 具体做法 这么做会使得输入的维度发生变化 是因为 mean 和std 方法会使得被操作的那个维度被消除，因此在操作是需要加入keepdim = True 这样使得输入的结果不会存在维度不同的问题 这里训练的效果依然不是很好 后续的方案 需要在输出加入残差 同时 可以增大hidden的大小 可以试着使用output做","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-11-02T13:51:19.629Z","updated":"2022-11-27T09:27:12.278Z","comments":true,"path":"2022/11/02/hello-world/","link":"","permalink":"http://example.com/2022/11/02/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"编程","slug":"programming","permalink":"http://example.com/categories/programming/"},{"name":"circuit","slug":"circuit","permalink":"http://example.com/categories/circuit/"},{"name":"概念","slug":"概念","permalink":"http://example.com/categories/%E6%A6%82%E5%BF%B5/"}],"tags":[]}